// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'blossom_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

BlossomBlob _$BlossomBlobFromJson(Map<String, dynamic> json) {
  return _BlossomBlob.fromJson(json);
}

/// @nodoc
mixin _$BlossomBlob {
  /// SHA-256 hash of the blob content (hex encoded)
  String get sha256 => throw _privateConstructorUsedError;

  /// Size of the blob in bytes
  int get size => throw _privateConstructorUsedError;

  /// MIME type of the blob (e.g., 'image/jpeg')
  String get mimeType => throw _privateConstructorUsedError;

  /// When the blob was uploaded to the server
  DateTime get uploadedAt => throw _privateConstructorUsedError;

  /// Full URL to access the blob
  String get url => throw _privateConstructorUsedError;

  /// Original filename (if provided during upload)
  String? get fileName => throw _privateConstructorUsedError;

  /// Blurhash for image previews (if generated by server)
  String? get blurhash => throw _privateConstructorUsedError;

  /// Image dimensions (if applicable)
  int? get width => throw _privateConstructorUsedError;
  int? get height => throw _privateConstructorUsedError;

  /// Serializes this BlossomBlob to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of BlossomBlob
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BlossomBlobCopyWith<BlossomBlob> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlossomBlobCopyWith<$Res> {
  factory $BlossomBlobCopyWith(
          BlossomBlob value, $Res Function(BlossomBlob) then) =
      _$BlossomBlobCopyWithImpl<$Res, BlossomBlob>;
  @useResult
  $Res call(
      {String sha256,
      int size,
      String mimeType,
      DateTime uploadedAt,
      String url,
      String? fileName,
      String? blurhash,
      int? width,
      int? height});
}

/// @nodoc
class _$BlossomBlobCopyWithImpl<$Res, $Val extends BlossomBlob>
    implements $BlossomBlobCopyWith<$Res> {
  _$BlossomBlobCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BlossomBlob
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sha256 = null,
    Object? size = null,
    Object? mimeType = null,
    Object? uploadedAt = null,
    Object? url = null,
    Object? fileName = freezed,
    Object? blurhash = freezed,
    Object? width = freezed,
    Object? height = freezed,
  }) {
    return _then(_value.copyWith(
      sha256: null == sha256
          ? _value.sha256
          : sha256 // ignore: cast_nullable_to_non_nullable
              as String,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      mimeType: null == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String,
      uploadedAt: null == uploadedAt
          ? _value.uploadedAt
          : uploadedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: freezed == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      blurhash: freezed == blurhash
          ? _value.blurhash
          : blurhash // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BlossomBlobImplCopyWith<$Res>
    implements $BlossomBlobCopyWith<$Res> {
  factory _$$BlossomBlobImplCopyWith(
          _$BlossomBlobImpl value, $Res Function(_$BlossomBlobImpl) then) =
      __$$BlossomBlobImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String sha256,
      int size,
      String mimeType,
      DateTime uploadedAt,
      String url,
      String? fileName,
      String? blurhash,
      int? width,
      int? height});
}

/// @nodoc
class __$$BlossomBlobImplCopyWithImpl<$Res>
    extends _$BlossomBlobCopyWithImpl<$Res, _$BlossomBlobImpl>
    implements _$$BlossomBlobImplCopyWith<$Res> {
  __$$BlossomBlobImplCopyWithImpl(
      _$BlossomBlobImpl _value, $Res Function(_$BlossomBlobImpl) _then)
      : super(_value, _then);

  /// Create a copy of BlossomBlob
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sha256 = null,
    Object? size = null,
    Object? mimeType = null,
    Object? uploadedAt = null,
    Object? url = null,
    Object? fileName = freezed,
    Object? blurhash = freezed,
    Object? width = freezed,
    Object? height = freezed,
  }) {
    return _then(_$BlossomBlobImpl(
      sha256: null == sha256
          ? _value.sha256
          : sha256 // ignore: cast_nullable_to_non_nullable
              as String,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      mimeType: null == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String,
      uploadedAt: null == uploadedAt
          ? _value.uploadedAt
          : uploadedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      fileName: freezed == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String?,
      blurhash: freezed == blurhash
          ? _value.blurhash
          : blurhash // ignore: cast_nullable_to_non_nullable
              as String?,
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BlossomBlobImpl implements _BlossomBlob {
  const _$BlossomBlobImpl(
      {required this.sha256,
      required this.size,
      required this.mimeType,
      required this.uploadedAt,
      required this.url,
      this.fileName,
      this.blurhash,
      this.width,
      this.height});

  factory _$BlossomBlobImpl.fromJson(Map<String, dynamic> json) =>
      _$$BlossomBlobImplFromJson(json);

  /// SHA-256 hash of the blob content (hex encoded)
  @override
  final String sha256;

  /// Size of the blob in bytes
  @override
  final int size;

  /// MIME type of the blob (e.g., 'image/jpeg')
  @override
  final String mimeType;

  /// When the blob was uploaded to the server
  @override
  final DateTime uploadedAt;

  /// Full URL to access the blob
  @override
  final String url;

  /// Original filename (if provided during upload)
  @override
  final String? fileName;

  /// Blurhash for image previews (if generated by server)
  @override
  final String? blurhash;

  /// Image dimensions (if applicable)
  @override
  final int? width;
  @override
  final int? height;

  @override
  String toString() {
    return 'BlossomBlob(sha256: $sha256, size: $size, mimeType: $mimeType, uploadedAt: $uploadedAt, url: $url, fileName: $fileName, blurhash: $blurhash, width: $width, height: $height)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlossomBlobImpl &&
            (identical(other.sha256, sha256) || other.sha256 == sha256) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.mimeType, mimeType) ||
                other.mimeType == mimeType) &&
            (identical(other.uploadedAt, uploadedAt) ||
                other.uploadedAt == uploadedAt) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.blurhash, blurhash) ||
                other.blurhash == blurhash) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, sha256, size, mimeType,
      uploadedAt, url, fileName, blurhash, width, height);

  /// Create a copy of BlossomBlob
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlossomBlobImplCopyWith<_$BlossomBlobImpl> get copyWith =>
      __$$BlossomBlobImplCopyWithImpl<_$BlossomBlobImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BlossomBlobImplToJson(
      this,
    );
  }
}

abstract class _BlossomBlob implements BlossomBlob {
  const factory _BlossomBlob(
      {required final String sha256,
      required final int size,
      required final String mimeType,
      required final DateTime uploadedAt,
      required final String url,
      final String? fileName,
      final String? blurhash,
      final int? width,
      final int? height}) = _$BlossomBlobImpl;

  factory _BlossomBlob.fromJson(Map<String, dynamic> json) =
      _$BlossomBlobImpl.fromJson;

  /// SHA-256 hash of the blob content (hex encoded)
  @override
  String get sha256;

  /// Size of the blob in bytes
  @override
  int get size;

  /// MIME type of the blob (e.g., 'image/jpeg')
  @override
  String get mimeType;

  /// When the blob was uploaded to the server
  @override
  DateTime get uploadedAt;

  /// Full URL to access the blob
  @override
  String get url;

  /// Original filename (if provided during upload)
  @override
  String? get fileName;

  /// Blurhash for image previews (if generated by server)
  @override
  String? get blurhash;

  /// Image dimensions (if applicable)
  @override
  int? get width;
  @override
  int? get height;

  /// Create a copy of BlossomBlob
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlossomBlobImplCopyWith<_$BlossomBlobImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

UploadProgress _$UploadProgressFromJson(Map<String, dynamic> json) {
  return _UploadProgress.fromJson(json);
}

/// @nodoc
mixin _$UploadProgress {
  /// Original filename being uploaded
  String get fileName => throw _privateConstructorUsedError;

  /// Bytes uploaded so far
  int get bytesUploaded => throw _privateConstructorUsedError;

  /// Total file size in bytes
  int get totalBytes => throw _privateConstructorUsedError;

  /// Current upload status
  UploadStatus get status => throw _privateConstructorUsedError;

  /// SHA-256 hash of the file (available after hashing)
  String? get sha256 => throw _privateConstructorUsedError;

  /// Error message if upload failed
  String? get error => throw _privateConstructorUsedError;

  /// Resulting blob URL (available after completion)
  String? get blobUrl => throw _privateConstructorUsedError;

  /// Server URL the file was uploaded to
  String? get serverUrl => throw _privateConstructorUsedError;

  /// Serializes this UploadProgress to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of UploadProgress
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $UploadProgressCopyWith<UploadProgress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UploadProgressCopyWith<$Res> {
  factory $UploadProgressCopyWith(
          UploadProgress value, $Res Function(UploadProgress) then) =
      _$UploadProgressCopyWithImpl<$Res, UploadProgress>;
  @useResult
  $Res call(
      {String fileName,
      int bytesUploaded,
      int totalBytes,
      UploadStatus status,
      String? sha256,
      String? error,
      String? blobUrl,
      String? serverUrl});
}

/// @nodoc
class _$UploadProgressCopyWithImpl<$Res, $Val extends UploadProgress>
    implements $UploadProgressCopyWith<$Res> {
  _$UploadProgressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of UploadProgress
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = null,
    Object? bytesUploaded = null,
    Object? totalBytes = null,
    Object? status = null,
    Object? sha256 = freezed,
    Object? error = freezed,
    Object? blobUrl = freezed,
    Object? serverUrl = freezed,
  }) {
    return _then(_value.copyWith(
      fileName: null == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      bytesUploaded: null == bytesUploaded
          ? _value.bytesUploaded
          : bytesUploaded // ignore: cast_nullable_to_non_nullable
              as int,
      totalBytes: null == totalBytes
          ? _value.totalBytes
          : totalBytes // ignore: cast_nullable_to_non_nullable
              as int,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as UploadStatus,
      sha256: freezed == sha256
          ? _value.sha256
          : sha256 // ignore: cast_nullable_to_non_nullable
              as String?,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      blobUrl: freezed == blobUrl
          ? _value.blobUrl
          : blobUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      serverUrl: freezed == serverUrl
          ? _value.serverUrl
          : serverUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UploadProgressImplCopyWith<$Res>
    implements $UploadProgressCopyWith<$Res> {
  factory _$$UploadProgressImplCopyWith(_$UploadProgressImpl value,
          $Res Function(_$UploadProgressImpl) then) =
      __$$UploadProgressImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String fileName,
      int bytesUploaded,
      int totalBytes,
      UploadStatus status,
      String? sha256,
      String? error,
      String? blobUrl,
      String? serverUrl});
}

/// @nodoc
class __$$UploadProgressImplCopyWithImpl<$Res>
    extends _$UploadProgressCopyWithImpl<$Res, _$UploadProgressImpl>
    implements _$$UploadProgressImplCopyWith<$Res> {
  __$$UploadProgressImplCopyWithImpl(
      _$UploadProgressImpl _value, $Res Function(_$UploadProgressImpl) _then)
      : super(_value, _then);

  /// Create a copy of UploadProgress
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fileName = null,
    Object? bytesUploaded = null,
    Object? totalBytes = null,
    Object? status = null,
    Object? sha256 = freezed,
    Object? error = freezed,
    Object? blobUrl = freezed,
    Object? serverUrl = freezed,
  }) {
    return _then(_$UploadProgressImpl(
      fileName: null == fileName
          ? _value.fileName
          : fileName // ignore: cast_nullable_to_non_nullable
              as String,
      bytesUploaded: null == bytesUploaded
          ? _value.bytesUploaded
          : bytesUploaded // ignore: cast_nullable_to_non_nullable
              as int,
      totalBytes: null == totalBytes
          ? _value.totalBytes
          : totalBytes // ignore: cast_nullable_to_non_nullable
              as int,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as UploadStatus,
      sha256: freezed == sha256
          ? _value.sha256
          : sha256 // ignore: cast_nullable_to_non_nullable
              as String?,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      blobUrl: freezed == blobUrl
          ? _value.blobUrl
          : blobUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      serverUrl: freezed == serverUrl
          ? _value.serverUrl
          : serverUrl // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$UploadProgressImpl extends _UploadProgress {
  const _$UploadProgressImpl(
      {required this.fileName,
      required this.bytesUploaded,
      required this.totalBytes,
      required this.status,
      this.sha256,
      this.error,
      this.blobUrl,
      this.serverUrl})
      : super._();

  factory _$UploadProgressImpl.fromJson(Map<String, dynamic> json) =>
      _$$UploadProgressImplFromJson(json);

  /// Original filename being uploaded
  @override
  final String fileName;

  /// Bytes uploaded so far
  @override
  final int bytesUploaded;

  /// Total file size in bytes
  @override
  final int totalBytes;

  /// Current upload status
  @override
  final UploadStatus status;

  /// SHA-256 hash of the file (available after hashing)
  @override
  final String? sha256;

  /// Error message if upload failed
  @override
  final String? error;

  /// Resulting blob URL (available after completion)
  @override
  final String? blobUrl;

  /// Server URL the file was uploaded to
  @override
  final String? serverUrl;

  @override
  String toString() {
    return 'UploadProgress(fileName: $fileName, bytesUploaded: $bytesUploaded, totalBytes: $totalBytes, status: $status, sha256: $sha256, error: $error, blobUrl: $blobUrl, serverUrl: $serverUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UploadProgressImpl &&
            (identical(other.fileName, fileName) ||
                other.fileName == fileName) &&
            (identical(other.bytesUploaded, bytesUploaded) ||
                other.bytesUploaded == bytesUploaded) &&
            (identical(other.totalBytes, totalBytes) ||
                other.totalBytes == totalBytes) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.sha256, sha256) || other.sha256 == sha256) &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.blobUrl, blobUrl) || other.blobUrl == blobUrl) &&
            (identical(other.serverUrl, serverUrl) ||
                other.serverUrl == serverUrl));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, fileName, bytesUploaded,
      totalBytes, status, sha256, error, blobUrl, serverUrl);

  /// Create a copy of UploadProgress
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UploadProgressImplCopyWith<_$UploadProgressImpl> get copyWith =>
      __$$UploadProgressImplCopyWithImpl<_$UploadProgressImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$UploadProgressImplToJson(
      this,
    );
  }
}

abstract class _UploadProgress extends UploadProgress {
  const factory _UploadProgress(
      {required final String fileName,
      required final int bytesUploaded,
      required final int totalBytes,
      required final UploadStatus status,
      final String? sha256,
      final String? error,
      final String? blobUrl,
      final String? serverUrl}) = _$UploadProgressImpl;
  const _UploadProgress._() : super._();

  factory _UploadProgress.fromJson(Map<String, dynamic> json) =
      _$UploadProgressImpl.fromJson;

  /// Original filename being uploaded
  @override
  String get fileName;

  /// Bytes uploaded so far
  @override
  int get bytesUploaded;

  /// Total file size in bytes
  @override
  int get totalBytes;

  /// Current upload status
  @override
  UploadStatus get status;

  /// SHA-256 hash of the file (available after hashing)
  @override
  String? get sha256;

  /// Error message if upload failed
  @override
  String? get error;

  /// Resulting blob URL (available after completion)
  @override
  String? get blobUrl;

  /// Server URL the file was uploaded to
  @override
  String? get serverUrl;

  /// Create a copy of UploadProgress
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UploadProgressImplCopyWith<_$UploadProgressImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BlossomResult<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T data) success,
    required TResult Function(String error) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T data)? success,
    TResult? Function(String error)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T data)? success,
    TResult Function(String error)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlossomSuccess<T> value) success,
    required TResult Function(BlossomFailure<T> value) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlossomSuccess<T> value)? success,
    TResult? Function(BlossomFailure<T> value)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlossomSuccess<T> value)? success,
    TResult Function(BlossomFailure<T> value)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlossomResultCopyWith<T, $Res> {
  factory $BlossomResultCopyWith(
          BlossomResult<T> value, $Res Function(BlossomResult<T>) then) =
      _$BlossomResultCopyWithImpl<T, $Res, BlossomResult<T>>;
}

/// @nodoc
class _$BlossomResultCopyWithImpl<T, $Res, $Val extends BlossomResult<T>>
    implements $BlossomResultCopyWith<T, $Res> {
  _$BlossomResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$BlossomSuccessImplCopyWith<T, $Res> {
  factory _$$BlossomSuccessImplCopyWith(_$BlossomSuccessImpl<T> value,
          $Res Function(_$BlossomSuccessImpl<T>) then) =
      __$$BlossomSuccessImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T data});
}

/// @nodoc
class __$$BlossomSuccessImplCopyWithImpl<T, $Res>
    extends _$BlossomResultCopyWithImpl<T, $Res, _$BlossomSuccessImpl<T>>
    implements _$$BlossomSuccessImplCopyWith<T, $Res> {
  __$$BlossomSuccessImplCopyWithImpl(_$BlossomSuccessImpl<T> _value,
      $Res Function(_$BlossomSuccessImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$BlossomSuccessImpl<T>(
      freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$BlossomSuccessImpl<T> extends BlossomSuccess<T> {
  const _$BlossomSuccessImpl(this.data) : super._();

  @override
  final T data;

  @override
  String toString() {
    return 'BlossomResult<$T>.success(data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlossomSuccessImpl<T> &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(data));

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlossomSuccessImplCopyWith<T, _$BlossomSuccessImpl<T>> get copyWith =>
      __$$BlossomSuccessImplCopyWithImpl<T, _$BlossomSuccessImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T data) success,
    required TResult Function(String error) failure,
  }) {
    return success(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T data)? success,
    TResult? Function(String error)? failure,
  }) {
    return success?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T data)? success,
    TResult Function(String error)? failure,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlossomSuccess<T> value) success,
    required TResult Function(BlossomFailure<T> value) failure,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlossomSuccess<T> value)? success,
    TResult? Function(BlossomFailure<T> value)? failure,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlossomSuccess<T> value)? success,
    TResult Function(BlossomFailure<T> value)? failure,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class BlossomSuccess<T> extends BlossomResult<T> {
  const factory BlossomSuccess(final T data) = _$BlossomSuccessImpl<T>;
  const BlossomSuccess._() : super._();

  T get data;

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlossomSuccessImplCopyWith<T, _$BlossomSuccessImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BlossomFailureImplCopyWith<T, $Res> {
  factory _$$BlossomFailureImplCopyWith(_$BlossomFailureImpl<T> value,
          $Res Function(_$BlossomFailureImpl<T>) then) =
      __$$BlossomFailureImplCopyWithImpl<T, $Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$BlossomFailureImplCopyWithImpl<T, $Res>
    extends _$BlossomResultCopyWithImpl<T, $Res, _$BlossomFailureImpl<T>>
    implements _$$BlossomFailureImplCopyWith<T, $Res> {
  __$$BlossomFailureImplCopyWithImpl(_$BlossomFailureImpl<T> _value,
      $Res Function(_$BlossomFailureImpl<T>) _then)
      : super(_value, _then);

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$BlossomFailureImpl<T>(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BlossomFailureImpl<T> extends BlossomFailure<T> {
  const _$BlossomFailureImpl(this.error) : super._();

  @override
  final String error;

  @override
  String toString() {
    return 'BlossomResult<$T>.failure(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BlossomFailureImpl<T> &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BlossomFailureImplCopyWith<T, _$BlossomFailureImpl<T>> get copyWith =>
      __$$BlossomFailureImplCopyWithImpl<T, _$BlossomFailureImpl<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T data) success,
    required TResult Function(String error) failure,
  }) {
    return failure(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(T data)? success,
    TResult? Function(String error)? failure,
  }) {
    return failure?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T data)? success,
    TResult Function(String error)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BlossomSuccess<T> value) success,
    required TResult Function(BlossomFailure<T> value) failure,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BlossomSuccess<T> value)? success,
    TResult? Function(BlossomFailure<T> value)? failure,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BlossomSuccess<T> value)? success,
    TResult Function(BlossomFailure<T> value)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class BlossomFailure<T> extends BlossomResult<T> {
  const factory BlossomFailure(final String error) = _$BlossomFailureImpl<T>;
  const BlossomFailure._() : super._();

  String get error;

  /// Create a copy of BlossomResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BlossomFailureImplCopyWith<T, _$BlossomFailureImpl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
